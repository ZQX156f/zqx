[TOC]



# 抽象类

学习目标:

- 掌握抽象类的定义
- 掌握抽象类的特点与使用

## 引例

以下猫狗继承案例，是一个非常基础的继承语法的代码。思考一下Animal类的继承体系，有什么问题吗？

从以下两个角度分析：

1. 从代码角度上，有没有冗余代码？
2. 从设计角度上，在这个案例中，会存在一个动物对象吗？

``` java
class Animal {
    public void shout() {
        System.out.println("动物叫");
    }
}
class Cat extends Animal {
    @Override
    public void shout() {
        System.out.println("猫叫");
    }
}
class Dog extends Animal {
    @Override
    public void shout() {
        System.out.println("狗叫");
    }
}
```

分析一下

1. 单纯从代码角度上，有没有冗余代码？

   实际上是有的。从方法调用的角度考虑，Animal类当中的shout方法从来没有被调用过。该方法单纯就是让子类继承并重写的，它实际上没有被调用的需求。从最理想的角度上来说，它的方法体是可以去掉的，仅保留一个声明让子类去重写就可以了。

2. 当然代码多几行少几行并不重要，重要是：从设计角度出发，Animal类是一个抽象的概念，用于指代所有动物。程序中根本不需要创建它的对象。而且对于一个抽象的概念，也不应该、也不可能去描述它的行为。

综上，我们提出两个改进的方向：

1. Animal类就是作为顶层抽象祖先类而存在的，不需要创建对象，于是干脆不要创建对象了。
2. Animal类当中的shout方法不需要方法体，仅用于作为被继承和重写一个方法声明。



**当父类的某些方法, 需要声明, 但是又不确定如何实现时, 可以将其声明为抽象方法, 那么这个类就是抽象类**



## 定义

按照上述构想我们首先把方法的方法体去掉，这样就得到一个抽象方法。它的语法是：

``` java
[修饰符列表] abstract 返回值类型 方法名(形参列表);
```

注：

1. 抽象方法没有方法体，只有方法的声明（方法头）。但是不要忘记写分号";"。
2. <span style=color:red;background:yellow>**抽象方法必须写在一个抽象类中。**</span>

接下来，我们定义抽象类。它的语法是：

``` java
[修饰符列表] abstract class 类名{
    //类体
}
```

通过测试，我们发现抽象类不能创建对象，但抽象类可以继承，存在子类。并且抽象类作为父类，多态现象仍然存在。

<span style=color:red;background:yellow>**在继承体系中，从祖先类开始，随着一个个子类的定义，子类变得越来越具体，而祖先类则更具有一般性和抽象性。在这种情况下，为了体现祖先类在设计上的抽象性，我们只将该类作为派生其他类的父类，而不能创建对象实例。这个时候，这样的类，我们称之为抽象类。**</span>

<img src="https://hixiaodong123.oss-cn-hangzhou.aliyuncs.com/typora/202201071337543.png?align=center" alt="抽象类继承图" style="zoom: 20%;" />

**上层的类越来越抽象，下层的类越来越具体。**



## 特点与使用

**特点**

抽象类的特点我们主要从以下角度：

1. 类名命名特点是什么?
2. 能用哪些修饰符？
3. 成员特点
   1. 普通成员
   2. 静态成员
   3. 抽象方法
4. 构造器
5. 代码块





**测试以后，结论如下：**

- 抽象类仍然是一个类，它的命名仍然需要遵循大驼峰的命名规范。当然，它比较特殊，许多公司的开发规范中，会要求将抽象类命名为`AbstracXxx`或`BaseXxx`，用于表示该类是一个抽象类。这是一个不错的命名习惯，推荐使用，但不强制。

- 类class在定义时，本身可以使用的修饰符就比较少，除了访问权限修饰符之外，几乎就只有final、abstract等少数修饰符。但是final和abstract在修饰类时是冲突的，不能放在一起使用。final是阻止继承而abstract是抽象类，如果不继承抽象类没有任何意义。

- 抽象类的成员特点：

  1. 成员变量。抽象类可以定义普通类中能够定义的所有成员变量，在这一点上，和普通类是一样的。

  2. 成员方法。抽象类可以定义普通类中能够定义的所有成员方法，包括普通成员方法和静态成员方法，在这一点上，和普通类仍然是一样的

     注：抽象类虽然不能创建对象，但是它有子类，这些具体实现方法可以让子类继承，子类可以选择直接使用，也可以选择重写，选择的权力在子类手上（假如一个方法在抽象类的多个子类中都需要被使用，那么就可以提取到抽象类中作为一个默认实现）

     综上，不能发现： <span style=color:red;background:yellow>**普通类中能够定义的成员，在抽象类中都是可以定义的。**</span>

  3. 抽象方法。首先抽象类可以没有抽象方法，但是如果一个抽象类没有抽象方法，那么它就没有必要声明为抽象，直接声明为普通类就够了。<font color=red>**定义出一个抽象类，就是为了定义抽象方法的。**</font>抽象方法最重要的作用是起到 <span style=color:red;background:yellow>**"占位"**</span> 的作用，任何普通类继承了该抽象类，都必须实现该抽象方法（强制的）

     如果子类不想实现抽象父类中的抽象方法，可以把子类也设置为抽象类，抽象类就不需要实现父类中的抽象方法了。

- 构造器。构造器除了可以自己用，创建对象时给成员变量赋值，还可以给子类用，在子类对象初始化过程中，可以调用父类的构造方法给父类的成员变量赋值。所以抽象类虽然不能创建对象，但它也是有构造器的。实际上，<span style=color:red;background:yellow>**在Java中，任何一个类都有构造器。**</span>

- 代码块，无论是构造代码块，还是静态代码块，都有。

综上：抽象类实际上和普通类能够定义的成员是一样的，普通类中有的东西它都有，只不过多了一个抽象方法。<span style=color:red;background:yellow>**在不考虑创建对象的情况下，直接把一个类声明为abstract，是不会编译报错的。**</span>

---

**使用**

**抽象类的使用，我们主要探讨，它的子类特点。**

抽象类的子类可以有两种情况：

1. 子类是普通类，普通类继承抽象类，必须实现所有的抽象方法。
2. 子类是抽象类，抽象子类不需要实现抽象方法，抽象子类可以自由选择实现（或实现或不实现）。

注：抽象类还可以继承一个普通类, 实际上如果一个抽象类, 它没有直接父类, 那它就直接继承Object

## 注意事项

1. abstract关键字，不能用来修饰构造器、属性、代码块等结构。只能修饰类或者方法。

2. abstract修饰类时，类的修饰符不能有final。

3. abstract修饰方法时，该方法不能有修饰符：

     1. private
     2. static
     3. final
4. 一个抽象类中可以没有抽象方法，但是没有意义

## 练习

1. 抽象类编码练习

> 公司正在开发一套员工管理系统，需要对公司内部存在的员工进行管理
>
> 公司将员工分为三类，普通员工负责杂项工作，程序员负责技术开发，经理负责统筹规划
>
> 普通员工包含3个属性：姓名、工号以及工资，行为是工作
>
> 程序员包含3个属性：姓名、工号以及工资，行为是工作和加班（overtime work）
>
> 经理包含4个属性：姓名、工号、工资以及奖金（bonus），行为是工作

- 请使用所学的知识设计该员工系统
- 要求类中提供必要的方法进行属性访问（description）

类图结构

![image-20221205144500325](img/image-20221205144500325.png)



2. 抽象类的作用是：做为继承体系中的顶层父类、祖先类而存在的。说白了所有继承了该抽象类的对象，都应该是一个该抽象类的对象。比如我定义了一个抽象的Person类，那么Student、Teacher等继承它是没问题的，但是让一个Cat继承就不行了（即便有成员可以复用）。<font color=red>**只要是继承，就必须考虑"is-a"关系。**</font>

```java
// 抽象的员工类
abstract class BaseStaff {
    private String name;
    private int id;
    private double salary;

    public BaseStaff(String name, int id, double salary) {
        this.name = name;
        this.id = id;
        this.salary = salary;
    }

    public abstract void work();

    // 定义打印属性的方法,子类可以选择直接使用,也可以选择重写
    public void printStaff() {
        System.out.println("id是" + id + "的员工,姓名是" + name + ",Ta的工资是" + salary);
    }

    public String getName() {
        return name;
    }

    public int getId() {
        return id;
    }

    public double getSalary() {
        return salary;
    }
}

class NormalStaff extends BaseStaff {
    public NormalStaff(String name, int id, double salary) {
        super(name, id, salary);
    }

    @Override
    public void work() {
        System.out.println("负责杂项工作");
    }


}

class Coder extends BaseStaff {
    public Coder(String name, int id, double salary) {
        super(name, id, salary);
    }

    @Override
    public void work() {
        System.out.println("负责技术开发");
    }

    public void overTimeWork() {
        System.out.println("996福报,蹭公司电,蹭公司网!");
    }
}

class Manager extends BaseStaff {
    double bonus;

    public Manager(String name, int id, double salary, double bonus) {
        super(name, id, salary);
        this.bonus = bonus;
    }

    @Override
    public void work() {
        System.out.println("负责统筹规划");
    }

    @Override
    public void printStaff() {
        System.out.println("id是" + getId() + "的员工,姓名是" + getName() + ",Ta的工资是" + (getSalary() + bonus));
    }
}

```



# 接口

学习目标:

- 掌握接口的定义
- 掌握接口的特点与使用

## 引例

在之前的猫狗案例中，我们将Animal类设置为抽象类，继承体系代码如下：

猫狗案例代码

``` java
abstract class Animal {
public abstract void shout();
}
class Cat extends Animal {
@Override
public void shout() {
  System.out.println("猫叫");
}
}
class Dog extends Animal {
@Override
public void shout() {
  System.out.println("狗叫");
}
}
```

现在我们有了新需求：一部分猫和狗，经过了特殊训练，能够直立行走了。那么这群特殊的猫和狗，怎么描述它们呢？

分析：

部分猫和狗经过特殊训练，才能够直立行走。所以不可能直接加个方法到Cat类和Dog类中，不是所有猫狗都有这个行为。而特殊的猫狗仍然是猫和狗，所以它们肯定还要继承猫和狗这两个类。可能很多同学，这时候想到的就是：重新定义两个新的猫狗类（比如超级狗和猫）继承猫狗，然后给出直立行走的方法就算完事了。这样做不是不行，需求是实现了，但还有一些小问题：

1. 一方面没有体现代码复用。
2. 更重要的是，没有体现出特殊训练的过程。假如还有一些动物也要直立行走，增加这个行为，如何体现出规范性、标准性呢？体现出它们是特殊的经过训练的动物呢？

这里我们想到了抽象类，因为抽象类中抽象方法，可以强制约束子类实现它，这样就是一种标准和规范，体现了它经过了特殊训练，和之前不同了。

于是我们定义抽象类，给出抽象方法，让超级猫狗类去继承这个抽象类，可行吗？

理想很美好，现实很骨感。显然做不到，因为Java不支持多继承。除开这点这么做也不是完美的，问题是：

1. 这个抽象类里面是对功能和行为的抽象，缺少属性（单独一个直立行走的行为是一个什么对象？）所以单独的行为不应该被抽象为类，不符合类的定义。
2. 继承这个抽象类也不符合继承的"is-a"关系，这里不适用继承（还是上面那句话，行为根本不是个体）

于是，我们就迫切需要一种全新的数据类型，这种全新的数据类型：

1. 不强调属性，只强调行为的抽象，"继承"它表示功能的扩展。
2. 在一个类继承某个类后，还能继续"继承"该类型，不受Java单继承限制。
3. 没有"is-a"这种继承关系的限制。
4. 最好还有抽象方法。（因为它能表示规范和标准）

这种全新的数据类型，就是**接口（interface）**。

## 定义

上面四条，其实已经描述了接口的特点，接口是一种表示对行为抽象的，不受Java单重继承限制的，用来作为功能扩展标准的一种引用数据类型。它的定义语法如下：

``` java
[访问权限修饰符] interface 接口名{
    
}
```

注：

- 接口的访问权限修饰符也只有两种：

  1. public 
  2. 默认缺省的

- 接口名和类名一样，遵循大驼峰式的书写规范，接口名最好起的见名知意。有些程序员喜欢在接口前加一个大写字母I来直接，表示该类型是一个接口，可以借鉴，但不强制。

- 接口中可以定义抽象方法，和抽象类中定义抽象方法没有区别。

- 接口是可以被一个类"继承"的，接口的"继承"，更准确、常见的叫法称之为接口的实现。当然它也不再使用extends关键字，而是使用 implements 关键字。一个普通类实现接口必须实现所有抽象方法。它的语法是：

  ``` java
   [访问权限修饰符] class 类名 extends 类名 implements 接口名 {}
  ```

  细节问题：如果一个类实现接口并继承别的类，要"先继承再实现"。关键字位置不要写反了。

- 在接口的实现中，可以称呼接口为"父接口"，接口的实现类为"子类"，它们仍然是父子关系。当然多态现象仍然能够发生。

- 接口不受单重继承限制，一个类可以在继承别的类的同时实现接口，而且可以实现多个接口。

## 优点

使用接口有如下优点：

- 接口不受单继承限制，这是接口非常重要的优点。
- 接口表示一种开发标准，一种规范。表示对功能的扩展，它只关注行为，不关注属性。

## 特点和使用

**接口的特点我们主要研究以下方面**

1. 接口的声明特点
   1. 接口能不能创建对象?
   2. 接口能不能用final修饰?
2. 接口的实现类的书写格式
3. 成员特点
   1. 能否定义属性(成员变量, 静态成员变量, 全局常量)?
   2. 能否定义方法/行为?
4. 构造器
5. 代码块

**测试后，我们的结论是：**

- **接口的声明特点**
  
  - 接口能不能创建对象?
    - 不能创建对象,实际上接口是抽象的. 因为接口的声明修饰符中隐含了关键字abstract
  - 接口能不能用final修饰?
    - 不能,接口定义出来目的就是为了被实现. final天生和接口矛盾
- **接口的命名特点(非强制)**
  
  - 接口在命名时,为了体现接口的特殊性,表示它是一个接口. 某些程序员会在接口的命名前加大写字母"I"
- **接口的实现类的书写格式(非强制)**
  
  - 某些程序员会在接口的所在位置,定义一个全新的包,叫"impl"
  - 然后在该包下写接口的实现类,命名为"接口名 + Impl"
- **成员特点**
  
  - 能不能定义属性?(成员变量,静态成员变量,全局常量)
    - 可以定义,但是接口中的属性默认都是"public static final"修饰的公共的全局常量
    - 这些隐含的修饰符不要写出来, 接口能够定义的所有结构的访问权限都是public, 而且public是隐含的修改不了
    - 接口中没有静态代码块,接口中的全局常量,必须显式赋值
    - 接口表示对功能的扩展,所以接口往往只有对行为的抽象(接口往往只有方法),接口是非常少见定义属性的, 只有当接口的所有实现类,都需要一个共同的全局常量时才考虑在接口中定义属性.
  - 能不能定义方法/行为?
    - 可以定义方法,但是接口中的方法默认都是"public abstract"修饰的公共的抽象方法
     - 实际上,在Java8之前,接口中没有任何实现方法,接口中只能定义抽象方法
     - 特别强调: 实际开发中,99%的情况下,接口就只有光秃秃的抽象方法定义,没有其他任何内容
- **构造器**
  
  - 接口是没有构造器的,接口自己用不到构造器
   *          接口的子类也用不到
- **代码块**
  
  - 没有静态代码块
   *          没有构造器就没有构造代码块
- **以上总结,接口能定义的结构特点:**
  
  - 可以定义全局常量
   *          可以定义抽象方法(Java8以后允许实现方法)
   - 实际上,接口往往只有抽象方法定义,它表示对行为的抽象, 表示制定标准和规范



**接口的使用，我们主要探讨它的子类特点。**

接口的子类可以是什么？

1. 普通类实现接口，必须实现所有的抽象方法。

2. 抽象类实现接口，按需实现抽象方法。

3. 接口可以继承一个接口，并且接口在继承接口后，可以重写父接口中的抽象方法和默认方法。

   参考如下代码（了解即可）：

   ``` java
   interface A {
       Object test();
      
       default void test2() {
       }
   }
      
   interface B extends A {
       /*
           重写父接口抽象方法
               只有在父接口的方法返回值类型是父类类型时
               子接口中可以将抽象方法返回值类型重写为子类类型
               其余地方都不可变。
        */
       @Override
       Demo test();
      
       @Override
       default void test2() {
           System.out.println();
       }
   }
   ```



**extends VS implements：**

继承（extends）是不能跨越种族的，类和类继承，接口和接口继承，接口和类之间没有继承关系。
1. 普通类继承一个抽象类，需要实现里面的所有抽象方法。
2. 抽象类继承一个抽象类，按需实现里面的抽象方法。
3. 抽象类继承一个普通类，是可以的。
4. 接口在继承一个接口后，会得到接口的所有抽象方法。
5. 类的继承是单继承的，接口的继承是多继承的。

实现（implements），必须发现在类与接口之间。
1. 普通类实现接口，必须实现所有抽象方法
2. 抽象类实现接口，按需实现抽象方法

## 默认方法和静态方法

**Java8中接口的语法迎来了大的变动，新增了两种具有方法体的实现方法：**

- 默认方法
- 静态方法



1. 默认方法。

   ``` java
   // 默认方法的语法:
   default 返回值类型 方法名(形参列表){	
       //方法体
   }
   ```

   - 接口中的默认方法的访问权限修饰符是public，不可更改。
   - 默认方法的作用：
      - 抽象类中的实现方法是用来作为子类的默认实现的，但是接口不具备这个功能。接口表示对功能的扩展，它更多的是一种标准和规范，多数情况下它不需要实现方法。
      - Java8仍然新增了默认方法，主要是两个角度考虑:
        - 接口中一旦有了默认实现方法，程序设计接口的灵活性就增加了。在没有默认方法时，接口中一旦新增任何方法，子类都必须实现它。而现在有了默认方法，就不需要这么做：需要实现的就自己重写，不需要的就直接继承。代码的兼容性和灵活性就增加了。
        - Java8中引入了Lambda表达式和StreamAPI，接口中的默认方法可以作为它们的实现，完成函数式编程。（这个仅了解）
      - 接口中的默认方法，还可以配合接口的"多实现"，实现真正意义上的多继承。

2. 静态方法。

   ``` java
static 返回值类型 方法名(形参列表){
       //方法体
   }
   ```
   
     - 接口中的静态方法也是默认public修饰的，不可更改。
  - 它的调用方式是用接口名.静态方法名。
     - 接口自从Java8以后有了静态方法，甚至可以写一个main方法。
     - **接口中的静态实现方法，只能自己用，不能用实现类类名调用。**

---

**上面两种方法仅供了解，实际开发中，可能会偶尔见到它，但自己写的概率非常小。**



## 练习

1. 教练（Coach）和运动员（Sportsman）案例

> 小试牛刀请用所学知识分析：这个案例中有哪些抽象类，哪些接口，哪些具体类。

现在有乒乓球运动员和篮球运动员，乒乓球教练和篮球教练。为了能够出国交流，跟乒乓球相关的人员都需要学习英语。





## 方法的形参和返回值类型

### 方法传值

方法的形参在方法调用传入实参时，不一定要求数据类型完全一致。

- **基本类型：**对于基本数据类型的方法形参，存在自动类型提升。
- **引用类型：** 对于引用数据类型的方法传参，存在自动向上转型。
  1. 形参如果写一个普通类：调用方法时需要传入的是该类的对象或者该类的子类对象
  2. 形参如果写一个抽象类：调用方法时需要传入的是该抽象类的子类对象
  3. 形参如果写一个接口：调用方法时需要传入的是该接口的子类对象

### 方法的返回值

方法的返回值类型，和在方法体中返回具体值（对象）时，不一定要求数据类型完全一致。

- **基本类型：**方法体中，返回一个具体的值不要求和返回值类型完全一致，存在自动类型提升。
- **引用类型：** 在方法体中，返回一个对象时不要求就是返回值类型的对象，存在自动向上转型。
  1. 返回值类型如果写一个普通类：可以返回该类的对象或者该类的子类对象
  2. 返回值类型如果写一个抽象类：返回该抽象类的子类对象。
  3. 返回值类型如果写一个接口：返回该接口的子类对象。

### 方法重写中的返回值类型问题

父子类方法重写中，方法声明中返回值类型的书写。

1. **基本类型和void：**必须保持一模一样，不存在类型提升。
2. **引用类型：**不必保持一模一样，存在自动向上转型。
   1. 类：父类中的方法返回一个普通类类型
      - 子类方法中可以返回该类型
      - 也可以返回该类的子类类型
   2. 抽象类：父类中的方法返回一个抽象类类型
      - 子类方法可以返回该类型
      - 也可以返回抽象类的实现类类型
   3. 接口：父类中的方法返回一个接口类型
      - 子类方法可以返回该类型
      - 也可以返回接口的实现类类型

## 链式调用

链式调用，在Java代码中是很常见的。当然它不是一个语法，这里讲一下它的形式，大家知道即可。

对于类Studnet：

``` java
class Student{

 public Student getStudent(){
     return new Student();
 }

 public Teacher getTeacher(){
    return new Teacher();
 }
}
class Teacher{
 public void show(){
     System.out.println("秀一波~~~");
 }
}
```

假如在main方法中写以下代码（不使用链式调用）：

``` java
StudentDemo sd = new StudentDemo();
Student s = sd.getStudent();
s.show();
```

使用链式调用的形式为：

``` java
new StudentDemo().getStudent().show();
```

<span style=color:red;background:yellow>**链式调用的本质在于：前面方法的返回值是一个对象。**</span>



# 接口 VS 抽象类

接口和抽象类的异同：

| 编号 | **区别点** |                          **抽象类**                          |                 **接口**                  |
| :--: | :--------: | :----------------------------------------------------------: | :---------------------------------------: |
|  1   |    定义    |                       包含抽象方法的类                       |         抽象方法和全局常量的集合          |
|  2   |    组成    |       构造方法、抽象方法、普通方法、常量、变量 代码块        | 常量、抽象方法、(jdk8:默认方法、静态方法) |
|  3   |    使用    |                   子类继承抽象类(extends)                    |         子类实现接口(implements)          |
|  4   |    关系    |                    抽象类可以实现多个接口                    |  接口不能继承抽象类，但允许继承多个接口   |
|  5   |    对象    |                 不能创建对象，但是有构造方法                 |       不能创建对象，也没有构造方法        |
|  6   |    局限    |                      抽象类不能被多继承                      |       接口之间能多继承，能被多实现        |
|  7   |    思想    |             作为模板或对共性属性和行为抽象，is-a             |     作为标准或对共性行为抽象，like-a      |
|  8   |  访问权限  |              抽象类的成员，写访问权限比较自由。              |      接口的成员，必须是public修饰的       |
|  9   |    选择    | **如果抽象类和接口都可以使用的话，优先使用接口，避免单继承的局限** |                                           |

总之，抽象类和接口除了都是抽象外，区别相当明显。抽象类是作为继承层次中的顶层父类存在的，接口则比较自由。 







