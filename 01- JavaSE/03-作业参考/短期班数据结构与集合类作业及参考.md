#  day1作业

## 判断链表是否有环

>有一个链表, 实现一个hasCircle()方法判断这个链表有没有环
>
>```java
>public static void main(String[] args) {
>
>   // a --> b --> c --> d --> e
>   Node e = new Node("e");
>   Node d = new Node("d", e);
>   Node c = new Node("c", d);
>   Node b = new Node("b", c);
>   Node a = new Node("a", b);
>
>   // a --> b --> c --> d --> e --> c --> d --> e --> ...
>   e.next = c;
>
>   boolean bool = hasCircle(a);
>   System.out.println(bool);
>}
>/**
>    * 判断链表是否有环
>    * @param head : 头结点
>    * @return : 是否有环
>    */
>   private static boolean hasCircle(Node head) {
>      
>   }
>
>class Node {
>   String value; // 结点的值域
>   Node next; // 结点的指向下一个结点的指针域
>   public Node(String value) {
>       this.value = value;
>   }
>   public Node(String value, Node next) {
>       this.value = value;
>       this.next = next;
>   }
>}
>```
>
>作业参考
>
>```java
>	/**
>    * 给定一个链表, 判断这个链表是否有环装结构
>    * @param head: 给的链表的头结点
>    * @return: 是否有环
>    */
>   private static boolean hasCircle(Node head) {
>       Node f = head; // 快指针
>       Node l = head; // 慢指针
>
>       // f后面还有内容 --> 向后遍历
>       while (f.next != null && f.next.next != null){
>           f = f.next.next;
>           l = l.next;
>
>           if (f == l){
>               // 快慢指针相遇 --> 有环, f快指针在环内绕回来了
>               return true;
>           }
>       }
>
>       return false;
>   }
>```

## 反转单链表

>有一个链表, 实现一个reLinked()方法获得这个链表的反转链表
>
>```java
>public static void main(String[] args) {
>
>   // 翻转链表
>   // a --> b --> c --> d --> e
>   Node e = new Node("e");
>   Node d = new Node("d", e);
>   Node c = new Node("c", d);
>   Node b = new Node("b", c);
>   Node a = new Node("a", b);
>
>   // e  --> d  -->  c  --> b  --> a
>   Node newLinked = reLinked(a);
>
>   System.out.println(newLinked);
>
>}
>	/**
>    * 翻转链表
>    * @param head : 原链表头结点
>    * @return : 经过翻转链表的头结点
>    */
>   private static Node reLinked(Node head) {
>
>   }
>```
>
>代码参考
>
>```java
>   /**
>    *  给定一个链表, 获得一个翻转链表
>    * @param head: 原链表的头结点
>    * @return:  经过翻转的链表的头结点
>    */
>   private static Node reLinked(Node head) {
>       Node reLinked = null;
>
>       Node mid = head; // 定义一个遍历结点, 用来遍历原链表
>
>       // 遍历结点不是null  --> 原链表还没有完成遍历
>       while (mid != null){
>           Node next = mid.next;
>           mid.next = reLinked;
>           reLinked = mid;
>           mid = next;
>       }
>
>       return reLinked;
>   }
>```



## 选作

如果链表已知有环,  给链表的头结点, 获得环的起始位置存储内容

>```java
>public static void main(String[] args) {
>
>   // a --> b --> c --> d --> e
>   Node e = new Node("e");
>   Node d = new Node("d", e);
>   Node c = new Node("c", d);
>   Node b = new Node("b", c);
>   Node a = new Node("a", b);
>
>   // a --> b --> c --> d --> e --> c --> d --> e --> ...
>   e.next = c;
>
>   String headvalue = getCircleHead(a);
>   System.out.println(headvalue);
>}
>   /**
>    * 如果一个链表有环, 获得环的起始位置元素
>    * @param head : 链表的头结点
>    * @return : 环的起始结点值
>    */
>   private static String getCircleHead(Node head) {
>      
>   }
>
>class Node {
>   String value; // 结点的值域
>   Node next; // 结点的指向下一个结点的指针域
>   public Node(String value) {
>       this.value = value;
>   }
>   public Node(String value, Node next) {
>       this.value = value;
>       this.next = next;
>   }
>}
>```
>
>代码参考
>
>```java
>   /**
>    * 给定一个有环的链表的头结点,   获取环的起始位置存储的内容
>    * @param head: 链表的头结点
>    * @return: 环的起始位置存储的内容
>    */
>   private static String getValue(Node head) {
>       Node  f = head;
>       Node  l = head;
>
>       while (f.next != null && f.next.next != null){
>           f = f.next.next;
>           l = l.next;
>
>           if (f == l){
>               break;
>           }
>       }
>       f = head;
>       while (f != l){
>          f = f.next;
>          l = l.next;
>       }
>       return f.value;
>   }
>```



# day2作业

## 敲上课代码

## MyLinkedList补全

在我们上课代码基础上(MyLinkedList), 实现根据下标的查找和修改方法(参考我们上课预留的方法体)



参考答案

>```java
>/**
>    * MyLinkedList根据下标的查找方法
>    * @param index: 提供的下标
>    * @return: 对应下标存储的内容
>    */
>public String get(int index){
>   // 判断下标是否合法
>   if (index < 0 || index >= size){
>       throw new IllegalArgumentException("param is Illegal");
>   }
>
>   int tag = 0;
>   Node mid = head;
>
>   while (tag != index){
>       mid = mid.next;
>       tag++;
>   }
>   // mid就是要查找的下标位置
>
>   return mid.value;
>}
>
>/**
>    * MyLinkedList的根据下标的修改方法
>    * @param index: 要修改的下标位置
>    * @param newValue: 用来替换的新值
>    * @return: 被覆盖/替换的旧值
>    */
>public String set(int index, String newValue){
>   // 判断下标是否合法
>   if (index < 0 || index >= size){
>       throw new IllegalArgumentException("param is Illegal");
>   }
>   int tag = 0;
>   Node mid = head;
>
>   while (tag != index){
>       mid = mid.next;
>       tag++;
>   }
>   // mid就是要查找的下标位置
>   String oldValue = mid.value;
>   mid.value = newValue;
>
>   return oldValue;
>}
>```

重点

重点在代码上, 要写; 除了代码别的都是次要的



# day3作业

## 敲上课代码

## 合并两个有序的链表

 合并两个有序的链表, 合并后链表也是有序的

> 例如:
> 			1  -> 2  --> 4  --> 8
> 			2  -> 3  --> 6  --> 9
> 结果: 
>
> 			1 --> 2  --> 2 --> 3  --> 4  --> 6  --> 8  --> 9
>
> 要求补全代码
>
> ```java
> public class Merge {
>  public static void main(String[] args) {
> 
> //        例如:
> //        1  -> 2  --> 4  --> 8
> //        2  -> 3  --> 6  --> 9
> //        结果: 1 --> 2  --> 2 --> 3  --> 4  --> 6  --> 8  --> 9
>      Node node18 = new Node(8, null);
>      Node node14 = new Node(4, node18);
>      Node node12 = new Node(2, node14);
>      Node node11 = new Node(1, node12);
> 
> 
>      Node node29 = new Node(9, null);
>      Node node26 = new Node(6, node29);
>      Node node23 = new Node(3, node26);
>      Node node21 = new Node(2, node23);
> 
>      Node mergeNode = mergeTwoLinked(node11, node21);
> 
>      System.out.println(mergeNode);
>  }
> 
>  private static Node mergeTwoLinked(Node node11, Node node21) {
> 
> 	// TODO 补全代码
>      return null;
>  }
> }
> 
> class Node{
>  int value;
>  Node next;
> 
>  public Node(int value, Node next) {
>      this.value = value;
>      this.next = next;
>  }
> }
> 
> ```
>
> 



参考答案

> ```java
> public class Merge {
>  public static void main(String[] args) {
> 
> //        例如:
> //        1  -> 2  --> 4  --> 8
> //        2  -> 3  --> 6  --> 9
> //        结果: 1 --> 2  --> 2 --> 3  --> 4  --> 6  --> 8  --> 9
>      Node node18 = new Node(8, null);
>      Node node14 = new Node(4, node18);
>      Node node12 = new Node(2, node14);
>      Node node11 = new Node(1, node12);
> 
> 
>      Node node29 = new Node(9, null);
>      Node node26 = new Node(6, node29);
>      Node node23 = new Node(3, node26);
>      Node node21 = new Node(2, node23);
> 
>      Node mergeNode = mergeTwoLinked(node11, node21);
> 
>      System.out.println(mergeNode);
>  }
> 
>  private static Node mergeTwoLinked(Node node11, Node node21) {
>      Node head = new Node(-1, null);
>      Node mid = head;
> 
>      while (node11 != null && node21!= null){
>          if (node11.value <= node21.value){
>              mid.next = node11;
>              node11 = node11.next;
>          }else {
>              mid.next = node21;
>              node21 = node21.next;
>          }
>          mid = mid.next;
>      }
> 
>      mid.next = node11 != null ? node11 : node21;
> 
>      return head.next;
>  }
> }
> 
> class Node{
>  int value;
>  Node next;
> 
>  public Node(int value, Node next) {
>      this.value = value;
>      this.next = next;
>  }
> }
> 
> ```



## 获取链表的倒数第x个结点内容

实现一个方法, 接收一个链表的头结点, 和int类型值x; 获取这个链表的倒数第x个结点内容

补全getValue方法

> ```java
> public class Test {
>  public static void main(String[] args) {
> 
>      Node node = new Node("a", new Node("b", new Node("c", new Node("d", new Node("e", null)))));
>      
>      String value = getValue(node, 2);
>  }
> 
>  /**
>      * 根据一个单链表的头结点, 或得链表倒数第x位置的结点存储内容
>      * @param head:单链表的头结点
>      * @param x: 数第x位置
>      * @return: 数第x位置存储的内容
>      */
>     public static String getValue(Node head, int x){
> 
>         return "";
>     }
> }
> class Node{
>     String value;
>     Node next;
> 
>     public Node(String value, Node next) {
>         this.value = value;
>         this.next = next;
>     }
> }
> 
> ```
>





参考代码

> ```java
>  public String getValue(Node head, int x){
> 
>      Node later = head;   // 后行结点
>      Node forward = head; // 先行结点
> 
>      // 先让先行结点向后移动x步
>      while (x != 0){
>          forward = forward.next;
>          x--;
>      }
> 
>      //此时, 先行结点和后行结点差x步
> 
>      // 同时单步后移
>      while (forward != null){
>          forward = forward.next;
>          later = later.next;
>      }
> 
>      return later.value;
>  }
> ```

重点

线性表相关的代码是重点





# day4作业

## 敲上课代码

## 使用栈模拟一个队列  

补全代码

>```java
>// 使用栈模拟一个队列   
>class MyQueue<T> {
>
>   //内部是栈在存储数据
>
>   public boolean offer();
>   public T poll();
>   public T peek();
>}
>```
>





参考代码

>```java
>// 使用栈模拟一个队列  
>public class MyQueue<T> {
>   MyArrayStack<T> stack1; // 栈1:  栈顶对应队尾,  栈底对应队头
>   MyArrayStack<T> stack2; // 栈2:  栈顶对应队头,  栈底对应队尾
>
>   public MyQueue() {
>       stack1 = new MyArrayStack<T>();
>       stack2 = new MyArrayStack<T>();
>   }
>
>   public void push(T x) {
>  stack1.push(x);
>    }
>
>public T pop() {
>      if (stack2.isEmpty()) {
>      while (!stack1.isEmpty()) {
>               stack2.push(stack1.pop());
>           }
>       }
>       return stack2.pop();
>    }
>
>   public T peek() {
>  if (stack2.isEmpty()) {
>          while (!stack1.isEmpty()) {
>          stack2.push(stack1.pop());
>           }
>       }
>       return stack2.peek();
>    }
>}
>```



## 使用队列模拟一个栈

补全代码

>```java
>// 使用队列模拟一个栈
>class MyStack<T> {
>
>   //内部是队列在存储数据
>
>   public boolean push();
>   public T pop();
>   public T peek();
>}
>```
>





参考答案

>```java
>// 使用队列模拟一个栈
>public class MyStack {
>   MyArrayQueue<Integer> queue1;
>   MyArrayQueue<Integer> queue2;
>
>   public MyStack() {
>       queue1 = new MyArrayQueue<Integer>();
>       queue2 = new MyArrayQueue<Integer>();
>   }
>   public void push(int x) {
>       queue2.offer(x);
>       while (!queue1.isEmpty()) {
>           queue2.offer(queue1.poll());
>       }
>       MyArrayQueue<Integer> temp = queue1;
>       queue1 = queue2;
>       queue2 = temp;
>   }
>   public int pop() {
>       return queue1.poll();
>   }
>   public int peek() {
>       return queue1.peek();
>   }
>
>}
>```





# day5作业

## 敲上课代码BST

## 代码补全

在我们上课实现的MyBSTree的基础上, 自行实现查找方法contains方法





参考答案

>```java
>/**
>    * 根据内容的查找方法
>    * @param value: 要查找的内容
>    * @return: 是否存在
>    */
>   public boolean contains(T value){
>       // 判断树是否为空
>       if (isEmpty()){
>           throw new RuntimeException("tree is empty");
>       }
>       // 判断删除的是否是null
>       if (value == null){
>           throw new IllegalArgumentException("value = " + value);
>       }
>
>       Node mid = root; // 定义一个遍历结点
>
>       // 当前遍历结点存在,  比较
>       while (mid != null){
>           int com = value.compareTo(mid.value);
>           if (com > 0){
>               // value值更大, 如果存在, 在mid的right侧
>               mid = mid.right;
>           }else if (com < 0){
>               // value值更小, 如果存在, 在mid的left侧
>               mid = mid.left;
>           }else {
>               // value值 和当前遍历的mid存储的内容相等
>               return true;
>           }
>       }
>
>       return false;
>   }
>```

## 选作

有兴趣可以写一下MyBSTree的删除内容的方法





# day6作业

## 判断二叉树是否镜像对称

 实现一个方法: 给定一个二叉树, 判断他是不是镜像对称的

>```java
>给定一个二叉树, 判断他是不是镜像对称的
>eg:对称
>   1
> ↙ ↘
>2     2
>↙ ↘ ↙ ↘
>3   4 4    3
>eg:不对称
>   1
> ↙ ↘
>2     2
> ↘    ↘
>  3      3
>```
>
>补全代码
>
>```java
>public static void main(String[] args) {
>
>   TreeNode node31 = new TreeNode(3);
>   TreeNode node32 = new TreeNode(3);
>   TreeNode node21 = new TreeNode(2, null, node31);
>   TreeNode node22 = new TreeNode(2, null, node32 );
>   TreeNode node11 = new TreeNode(1, node21, node22);
>
>   Ex3 ex3 = new Ex3();
>   boolean symmetric = ex3.isSymmetric(node11, node11);
>   System.out.println(symmetric);
>
>//        TreeNode node31 = new TreeNode(3);
>//        TreeNode node41 = new TreeNode(4);
>//        TreeNode node32 = new TreeNode(3);
>//        TreeNode node42 = new TreeNode(4);
>//        TreeNode node21 = new TreeNode(2, node31, node41);
>//        TreeNode node22 = new TreeNode(2, node42, node32);
>//        TreeNode node1 = new TreeNode(1,node21, node22);
>
>//        Ex3 ex3 = new Ex3();
>//        boolean symmetric = ex3.isSymmetric(node1, node1);
>//        System.out.println(symmetric);
>
>
>}
>
>public boolean isSymmetric(TreeNode root1, TreeNode root2){
>  
>}
>```
>







代码参考

>```java
>public class Ex3 {
>public static void main(String[] args) {
>//            3, 给定一个二叉树, 判断他是不是镜像对称的
>//            eg:对称
>//               1
>//             ↙ ↘
>//            2     2
>//          ↙ ↘ ↙ ↘
>//         3   4 4    3
>//            eg:不对称
>//               1
>//             ↙ ↘
>//            2     2
>//            ↘    ↘
>//             3     3
>   TreeNode node31 = new TreeNode(3);
>   TreeNode node32 = new TreeNode(3);
>   TreeNode node21 = new TreeNode(2, null, node31);
>   TreeNode node22 = new TreeNode(2, null, node32 );
>   TreeNode node11 = new TreeNode(1, node21, node22);
>
>   Ex3 ex3 = new Ex3();
>   boolean symmetric = ex3.isSymmetric(node11, node11);
>   System.out.println(symmetric);
>
>
>
>}
>
>public boolean isSymmetric(TreeNode root1, TreeNode root2){
>   if (root1 == null && root2 == null)return true;
>
>   if (root1 == null || root2 == null) return false;
>
>
>   return
>           root1.value == root2.value
>           &&   isSymmetric(root1.left, root2.right)
>                   && isSymmetric(root1.right, root2.left);
>}
>}
>
>```



## 反转二叉树

 实现一个方法: 反转二叉树

>```java
>反转二叉树
>eg : 原
>   4
> ↙ ↘
>2     7
>↙ ↘ ↙ ↘
>1   3 6   9
>-------------反转------
>   4
> ↙ ↘
>7     2
>↙ ↘ ↙ ↘
>9   6 3   1
>
>```

>```java
>反转二叉树
>eg : 原
>   4
> ↙ ↘
>2     7
>↙ ↘ ↙ ↘
>1   3 6   9
>-------------反转------
>   4
> ↙ ↘
>7     2
>↙ ↘ ↙ ↘
>9   6 3   1
>
>```
>
>补全代码
>
>```java
>public static void main(String[] args) {
>
>
>   TreeNode node1 = new TreeNode(1);
>   TreeNode node3 = new TreeNode(3);
>   TreeNode node6 = new TreeNode(6);
>   TreeNode node9 = new TreeNode(9);
>   TreeNode node2 = new TreeNode(2, node1, node3);
>   TreeNode node7 = new TreeNode(7, node6, node9);
>   TreeNode node4 = new TreeNode(4,node2, node7);
>
>
>   Ex4 ex4 = new Ex4();
>   TreeNode treeNode = ex4.invertTree(node4);
>   System.out.println(treeNode);
>
>
>}
>
>public TreeNode invertTree(TreeNode root){
>
>}
>```
>









作业参考

>```java
>public class Ex4 {
>public static void main(String[] args) {
>
>//        4, 反转二叉树
>//        eg : 原
>//           4
>//         ↙ ↘
>//        2     7
>//      ↙ ↘ ↙ ↘
>//     1   3 6   9
>//                -------------反转------
>//           4
>//         ↙ ↘
>//        7     2
>//      ↙ ↘ ↙ ↘
>//     9   6 3   1
>
>   TreeNode node1 = new TreeNode(1);
>   TreeNode node3 = new TreeNode(3);
>   TreeNode node6 = new TreeNode(6);
>   TreeNode node9 = new TreeNode(9);
>   TreeNode node2 = new TreeNode(2, node1, node3);
>   TreeNode node7 = new TreeNode(7, node6, node9);
>   TreeNode node4 = new TreeNode(4,node2, node7);
>
>
>   Ex4 ex4 = new Ex4();
>   TreeNode treeNode = ex4.invertTree(node4);
>   System.out.println(treeNode);
>
>
>}
>
>public TreeNode invertTree(TreeNode root){
>   if (root == null) return null;
>   TreeNode invertRight = invertTree(root.right);
>   TreeNode invertLeft = invertTree(root.left);
>
>   root.left = invertRight;
>   root.right = invertLeft;
>   return root;
>}
>}
>
>```

重点

二叉树的遍历(层级/前/中/后)思想逻辑和代码实现

补充的红黑树/B树/avl等在文档上总结的特点 (尤其注意: 上课讲的图和过程并不重要, 重要的是文档上总结的结论)



# day7作业

## 作业一

题目描述:

如果存在一个Collection中存储了多个User对象,其中有一些User数据是重复的. 获得一个包含不重复User的Collection集合(假设只使用Collection定义的api)







参考答案

>```java
>import java.util.ArrayList;
>import java.util.Collection;
>import java.util.Iterator;
>import java.util.Objects;
>
>public class DemoCollection {
>public static void main(String[] args) {
>
>   Collection<User> collection = new ArrayList<>();
>   collection.add(new User("zs", 18));
>   collection.add(new User("zs", 18));
>   collection.add(new User("ls", 18));
>   collection.add(new User("ls", 18));
>   collection.add(new User("wu", 18));
>   collection.add(new User("wu", 18));
>
>   Collection<User> newCollection = new ArrayList<>();
>
>   Iterator<User> iterator = collection.iterator();
>   while (iterator.hasNext()){
>       User next = iterator.next();
>       if (! newCollection.contains(next))
>           newCollection.add(next);
>   }
>
>   System.out.println(newCollection);
>
>}
>}
>class User{
>String name;
>int age;
>
>public User(String name, int age) {
>   this.name = name;
>   this.age = age;
>}
>
>@Override
>public boolean equals(Object o) {
>   if (this == o) return true;
>   if (o == null || getClass() != o.getClass()) return false;
>   User user = (User) o;
>   return age == user.age &&
>           Objects.equals(name, user.name);
>}
>
>@Override
>public int hashCode() {
>   return Objects.hash(name, age);
>}
>
>@Override
>public String toString() {
>   return "User{" +
>           "name='" + name + '\'' +
>           ", age=" + age +
>           '}';
>}
>}
>```



## 作业二

题目描述

如果List中存储了多个User对象, 去除重复元素(多个重复元素仅保留一个)(假设使用List所定义的的api来做)







参考代码

>```java
>// 去除重复元素
>ArrayList<User> list = new ArrayList<>();
>list.add(new User("zs", 18));
>list.add(new User("zs", 18));
>list.add(new User("ls", 18));
>list.add(new User("ls", 18));
>list.add(new User("wu", 18));
>list.add(new User("wu", 18));
>
>Iterator<User> iterator = list.iterator();
>while (iterator.hasNext()){
>User next = iterator.next();
>if (list.indexOf(next) != list.lastIndexOf(next)){
>   iterator.remove();
>}
>}
>
>System.out.println(list);
>```





## 作业三

题目描述

假设有一个字符串"abcqweracb" 在不改变前后顺序的前提下去除重复的字符得到"abcqwer"(结合使用ArrayList)

>```Java
>/**
>    * 给定一个字符串, 去除这个字符串中重复的数值, 得到一个不变前后顺序的不重复字符串
>    * @param str: 给定字符串
>    * @return: 去除重复值的字符串
>    */
>   private static String removeRepeat(String str) {
>      
>   }
>```





参考答案

>```java
>public static void main(String[] args) {
>
>String str = "abcqweracb";
>String norepeat = removeRepeat(str);
>System.out.println(norepeat);
>
>}
>
>/**
>   * 给定一个字符串, 去除这个字符串中重复的数值, 得到一个不重复的字符串
>   * @param str: 给定字符串
>   * @return: 去除重复值的字符串
>   */
>  private static String removeRepeat(String str) {
>      ArrayList<Character> list = new ArrayList<>();
>
>      for (int i = 0; i < str.length(); i++) {
>          if (!list.contains(str.charAt(i))){
>              list.add(str.charAt(i));
>          }
>      }
>
>      StringBuffer buffer = new StringBuffer();
>      for (int i = 0; i < list.size(); i++) {
>          buffer.append(list.get(i));
>      }
>
>      return buffer.toString();
>}
>```



## 作业四

题目描述

生成一个双色球中奖号码存储到ArrayList中

>双色球: 
>
>前6个红球，只能是01-33之间的号，并且六个号码不能重复
>
>后1个蓝球，只能是01-12之间的号。





参考代码

>```java
>public static void main(String[] args) {
>ArrayList<Integer> list = new ArrayList<>();
>
>Random random = new Random();
>
>while (list.size() < 6){
>  int bollnum = random.nextInt(33) + 1;
>  if (!list.contains(bollnum)){
>      list.add(bollnum);
>  }
>}
>
>list.add(random.nextInt(16) + 1);
>System.out.println(list);
>}
>```

重点

各个集合类的特点和api (文档上记录的内容)

了解

源码





# day8作业

## 找出重复

> 给定两个字符串s和t, 它们只包含小写字母。字符串t是由s中的字母随机打乱之后，在随机的一个位置添加一个字母生成的。请找出那个添加的字母。
>
> 比如：
> 	s = "abcd"
> 	t = "baedc"
> 	输出：e





参考代码:

>```java
>// 思路1：
>// 遍历s和t, 将字符作为key, 它出现的次数作为值, 存入到Map中。
>// 遍历Map, 找到值为奇数的key。这个key就是新添加的字母。
>String s = "abcd";
>String t = "baedc";
>
>Map<Character, Integer> map = new HashMap<>();
>
>// 遍历源字符
>for (int i = 0; i < s.length(); i++) {
>// 获取每个遍历字符
>Character charAt = s.charAt(i);
>
>// 判断这个字符是否在map中存在
>if (map.containsKey(charAt)){
>   // 存在, 保存出现次数+1
>   map.put(charAt, map.get(charAt)+1);
>}else {
>   // 不存在, 保存当前出现次数1
>   map.put(charAt, 1);
>}
>}
>
>// 遍历新字符
>for (int i = 0; i < t.length(); i++) {
>
>// 获取每个遍历字符
>Character charAt = t.charAt(i);
>
>// 判断这个字符是否在map中存在
>if (map.containsKey(charAt)){
>   // 存在, 保存出现次数+1
>   map.put(charAt, map.get(charAt)+1);
>}else {
>   // 不存在, 保存当前出现次数1
>   map.put(charAt, 1);
>}
>}
>
>
>// 找到值为奇数的key。这个key就是新添加的字母
>
>// 获得所有key-value
>Set<Map.Entry<Character, Integer>> entries = map.entrySet();
>
>// 遍历所有key-value
>for (Map.Entry<Character, Integer> entry : entries) {
>// 如果某个key-value的value 不是偶数
>if (entry.getValue() % 2 != 0){
>   // 就是新添加的字符
>   System.out.println(entry.getKey());
>}
>}
>```
>
>```java
>// 思路2:
>// 我们可以利用异或操作。利用 x ^ x = 0; 0 ^ x = x;
>public char findTheDifference(String s, String t) {
>int xor = 0;
>for(int i = 0; i < s.length(); i++) {
>   xor = xor ^ s.charAt(i);
>}
>for(int i = 0; i < t.length(); i++) {
>   xor = xor ^ t.charAt(i);
>}
>return (char) xor;
>}
>```

## 统计次数

题目描述

> "aababcabcdabcde",获取字符串中每一个字母出现的次数要求结果:a(5)b(4)c(3)d(2)e(1)





参考代码

>    ```java
>    String str = "aababcabcdabcde";
>    HashMap<Character, Integer> hashMap = new HashMap<>();
>    
>    for (int i = 0; i < str.length(); i++) {
>     char c = str.charAt(i);
>     boolean b = hashMap.containsKey(c);
>     if (b){
>         // 已经存储, 给value值加一
>         hashMap.put(c, hashMap.get(c)+1);
>     } else {
>         hashMap.put(c, 1);
>     }
>    }
>    StringBuffer buffer = new StringBuffer();
>    for (Character character : hashMap.keySet()) {
>     buffer.append(character);
>     buffer.append("(" + hashMap.get(character) + ")");
>    }		
>    ```

## 删除数据

题目描述

> 已知HashMap存储了一批数据 HashMap<String, Integer>;   删除这批数据key-value中value为7或者9的数据



参考代码

> ```java
> //        已知HashMap存储了一批数据 HashMap<String, Integer>;
> //        删除这批数据中key-value为7或者8或者9的数据
> 
>      HashMap<String, Integer> map = new HashMap<>();
>      map.put("a", 7);
>      map.put("b", 7);
>      map.put("c", 10);
>      map.put("d", 8);
>      map.put("e", 12);
>      map.put("f", 9);
>      map.put("g", 4);
>      map.put("h", 5);
>      map.put("i", 6);
>      map.put("j", 20);
> 
> //        // 方式一:
> //        ArrayList<Integer> list = new ArrayList<>();
> //        list.add(7);
> //        list.add(9);
> //
> //        // 获得值集视图
> //        Collection<Integer> values = map.values();
> //        // 在视图中删除7,9等于删除源数据
> //        values.removeAll(list);
> //
> //        System.out.println(map);
> 
> 
> 
> //        // 方式二:
> //        HashMap<String, Integer> map2 = new HashMap<>();
> //        // 遍历旧数据
> //        Set<Map.Entry<String, Integer>> entries = map.entrySet();
> //        for (Map.Entry<String, Integer> entry : entries) {
> //            // value不是7,8,9转移到新map
> //            if (entry.getValue() != 7 && entry.getValue() != 9 ){
> //                map2.put(entry.getKey(), entry.getValue());
> //            }
> //        }
> //        System.out.println(map2);
> 
> 
> 
> 
> //        // 方式三: 这个方式属于Java中Stream流的写法, 如果大家对java中Stream流有兴趣, 我后面回提供一份补充视频, 专门讲Stream流
> //        Map<String, Integer> collect = map.entrySet().stream()
> //                .filter(a -> a.getValue() != 7   && a.getValue() != 9)
> //                .collect(Collectors.toMap(a -> a.getKey(), a -> a.getValue()));
> //
> //        System.out.println(collect);
> ```

## 获取下标

题目描述

>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数, 返回它们的索引。
>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。
>
>比如：nums = [2, 7, 11, 15], target = 9.  
>   因为 nums[0] + nums[1] = 2 + 7 = 9. 所以返回 [0, 1].





参考代码

>```java
>public class Test {
>public static void main(String[] args) {
>
>   int [] nums = {2, 7, 11, 15};
>   int target = 13;
>
>   HashMap<Integer, Integer> map = new HashMap<>();
>
>   // 遍历数组
>   for (int i = 0; i < nums.length; i++) {
>
>       // 让目标值减去当前遍历数组元素
>       int other = target - nums[i];
>
>       // 判断other(另一半的数据组成)是否已经存储到map中了
>       boolean b = map.containsKey(other);
>       if (b){
>
>           int otherIndex = map.get(other);
>           System.out.println("["+ otherIndex + "," + i + "]" );
>           break;
>       } else {
>           map.put(nums[i], i);
>       }
>   }
>}
>}
>```

重点

1, 要好好理解各个集合类的特点和思想

2, 好好体会HashMap的各中设计机制和理念





# day9作业

## 作业一

题目描述

1,   假如我们拥有一个 学生列表,我们要对这个学生列表进行处理得到来自北京同学, 并且高度最高的三个同学(TreeMap 或者TreeSet)

```java
public class StudentList {
public List<Person> personList ;

public StudentList(){
   this.personList = new ArrayList<>();

   personList.add(new Person("aa", 18, 170, Person.Address.BJ));
   personList.add(new Person("bb", 20, 163, Person.Address.SH));
   personList.add(new Person("cc", 30, 182, Person.Address.WH));
   personList.add(new Person("dd", 16, 190, Person.Address.BJ));
   personList.add(new Person("ee", 15, 210, Person.Address.SH));
   personList.add(new Person("ff", 17, 160, Person.Address.WH));
   personList.add(new Person("gg", 18, 169, Person.Address.BJ));
   personList.add(new Person("hh", 20, 173, Person.Address.WH));
   personList.add(new Person("ii", 22, 192, Person.Address.SH));
   personList.add(new Person("jj", 25, 172, Person.Address.SH));
   personList.add(new Person("kk", 24, 188, Person.Address.BJ));
   personList.add(new Person("ll", 17, 161, Person.Address.WH));
   personList.add(new Person("mm", 18, 169, Person.Address.SH));
   personList.add(new Person("nn", 20, 162, Person.Address.BJ));
   personList.add(new Person("oo", 22, 166, Person.Address.SH));
   personList.add(new Person("pp", 24, 176, Person.Address.WH));
   personList.add(new Person("qq", 22, 173, Person.Address.BJ));
   personList.add(new Person("rr", 24, 177, Person.Address.BJ));
   personList.add(new Person("ss", 17, 169, Person.Address.SH));
   personList.add(new Person("tt", 18, 170, Person.Address.SH));
   personList.add(new Person("uu", 20, 171, Person.Address.WH));
   personList.add(new Person("vv", 22, 172, Person.Address.WH));
   personList.add(new Person("ww", 24, 181, Person.Address.BJ));
   personList.add(new Person("xx", 18, 188, Person.Address.SH));
   personList.add(new Person("yy", 20, 183, Person.Address.BJ));
   personList.add(new Person("zz", 22, 191, Person.Address.WH));

}
}
public class Person {
    public enum Address{
       BJ,
       SH,
       WH,
       SZ
    }
    private String name;
    private int age;
    private int height;
    private Address address;
}
```







作业参考

>```java
>	TreeSet<Person> peoples = new TreeSet<>(new Comparator<Person>() {
>       @Override
>       public int compare(Person o1, Person o2) {
>           int com = o2.getHeight() - o1.getHeight();
>           return com;
>       }
>   });
>
>   for (Person person : personList) {
>       if (person.getAddress() == Person.Address.BJ){
>           peoples.add(person);
>       }
>   }
>
>   System.out.println(peoples.first());
>   peoples.pollFirst();
>   System.out.println(peoples.first());
>   peoples.pollFirst();
>   System.out.println(peoples.first());
>   peoples.pollFirst();
>```











